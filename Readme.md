В связи с тем, что Entity описана достаточно абстрактно и не привязана к конкретным примерам я делаю ряд предположений:
1. ID не генерируется в БД и задаётся на уровне приложения (автогенерируется в коде, приходит с фронта, etc.)
2. Все поля относятся к сущности и не требуется выделения отдельных таблиц/сущностей
3. Поля, помеченные как val неизменяемые по бизнес-требованиям, поля помеченные var могут обновляться в БД.

Сначала разберёмся с типами полей: 
1. Если ID не генерируется в БД, то он должен быть NOT NULL. Будем заполнять его рандомным UUID если не указан явно.
2. Поле documentDate заменим на LocalDate вместо String. Не известно в каком формате здесь предполагается дата, но
в любом случае надо приводить её к одному из типов java.time и хранить в БД в одном из типов БД (DATE, DATETIME,
TIMESTAMP, etc.)
3. Если documentId и documentDate относятся к данной сущности, то вероятно вместо суррогатного Id надо использовать 
составной ПК documentId + documentDate.
Если же это ссылка на другую сущность, то поля documentDate не должно быть, т.к. это нарушает нормальную форму БД.
Аналогичная ситуация с полями dictionaryValueId/dictionaryValueName и testId/testName. Кроме того, не понятно почему
dictionaryValueName имеет тип UUID, по логике если это Name, то оно должно быть String.
Явных связей с другими Entity в примере нет, так что предполагается, что эти поля имеют какое-то отношение к
нашей Entity и выносить их не следует.
4. Назначение поля sortOrder не до конца понятно, но вероятно что его можно заменить на какую-то константу с ограниченным
набором значений. Заменим на enum SortOrder. В БД будем записывать его как varchar.

Теперь стоит разобраться с самим классом. JPA требует чтобы `@Entity` была открытая (non-final), имела no-args конструктор
и getter'ы тоже были открытые. По этой причине мы откажемся от data-класса и заменим его на `open class`. 

Теперь нужно разобраться с ID.
UUID не автогенерируемый. Можно сделать автогенерацию через встроенные функции БД, но тогда будет недоступен батчинг. 
Чтобы в Hibernate корректно работал батчинг, необходимо либо иметь сиквенс с большим аллокейшном, либо генерировать ID на стороне кода.
Т.к. ID не автогенерируемый, следует добавить интерфейс Persistable<UUID> чтобы уменьшить оверхед при создании новых
сущностей. Таким образом, метод `CrudRepository.save` будет вызывать `EntityManager.persist` вместо `EntityManager.merge` для новых сущностей.
Но есть нюанс - если мы хотим сделать обновление по ID через save, то придётся явно передавать в конструктор new = false.
Здесь надо исходить из того, что будет происходить чаще: обновление сущности или добавление новых.
